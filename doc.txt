        __ПРЕПРОЦЕССОР___
1) МАКРОСЫ
Синтаксис:
    #def @имя_макроса(входные_параметры,...){тело_макроса};
    Входные параметры небходимо перечислять через запятую без пробелов(они учитываються при парсинге).
    В теле макроопределения можно вызывать и другие макросы а так же можно в параметры передавать
    константные выражения. Все отступы и переходы в теле макроса (то что  между {} ) будут  так же
    учитываться при распоковке (при вызове макроса).

    Пример

    #def @SUM(num1,num2){num1+num2};
    #def @SUB(var1,var2){
    var1-var2
    };

    int sum = @SUM(1,2); // будет распоковано как: int sum = 1+2;
    int sub = @SUB(10,4); // будет расспаковано как: int sub = \n10-4\n да все символы \n,\r,\f,\t учитываються в теле макроса


2) КОНСТАНТНЫЕ ВЫРАЖЕНИЯ
Синтаксис:
    #const @имя_константного_выражения=значение;
    При обьявления константного выражения пробельные символы начиная с символа @ считаютьяс частью имени выражения или/и его значения,
     т.е. лучше опходиться без пробелов после символа @, тоесть cледует учесть что константные выражения должны тутже инициализированные значением,
     тоесть они не должны быть без значения и так же переприсвоить им новое значение нельзя.

     Пример

     #const @VAR1=12;
     #const @VAR2=12+34/434%1.5;
     #const @VAR_MSG = "hello world";

3) ИМПОРТ ФАЙЛОВ(ТЕКСТА)
Синтаксис:
    #import имя_файла;
    Данный макрос просто парсит, берет иям файла которое должно импортироваться, берет все содержимое из импортируемого
    файла и подставляет на место директивы #import file_name;
    Следует учесть что если файл не найден или не доступен данному пользователю выбрасываеться исключение. По default'у ищет указанные файлы в
    той директории в которой находться программа, для доступа к другим файлам можно указывать полный путь.

    Пример

    #import file_head.txt;

4) ДИРЕКТИВЫ УСЛОВНОЙ КОМПИЛЯЦИИ
Синтаксис:
    #if_def @константное_выражение      #if_def @константное_выражение
    ....                                ....
    #els_def                            #end_def
    ....
    #end_def

    Данной директивой вы можете определять каие части текста программы должны попасть на вход компилятору а каие должны быть вырезаны
    задавая условия в виде 1 или 0 (true and false). Так же следует учесть что блок #els_def дослжен строго следовать после блока #if_def
    а не через спустя n количество других символов. Так же конец области директив условной компиляции всегда закрывать выражением #end_def.

    Пример

    #const @DEBUG1=1;

    #if_def @DEBUG1             /* в результате компилятору попадет:
        print "block_if_def"        print "block_if_def" а блок
    #els_def                        #els_def будет проигнорирован */
        print "block_els_def"
    #end_def




